<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++ stl 笔记</title>
    <link href="/2022/06/27/NOTE-cpp-STL/"/>
    <url>/2022/06/27/NOTE-cpp-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="常用容器的一些使用细节">常用容器的一些使用细节</h1><h2 id="pair">pair</h2><blockquote><p>pair是将两个类型的变量关联在一起的容器,可以用在函数返回值的传递,在map中也有大量的应用</p></blockquote><p><strong>pair的构造方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//通过分别赋值</span><br>    std::pair&lt;<span class="hljs-type">int</span>,std::string&gt; p;<br>    p.first = <span class="hljs-number">1</span>;<br>    p.second = <span class="hljs-string">&quot;pair&quot;</span>;<br><br><span class="hljs-comment">//通过构造函数</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>,std::string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;pair&quot;</span>)</span></span>;<br><br><span class="hljs-comment">//通过make_pair函数</span><br>    std::pair&lt;<span class="hljs-type">int</span>,std::string&gt; p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;pair&quot;</span>);<br>    <span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;pair&quot;</span>);<span class="hljs-comment">//使用auto来简化流程</span><br><br></code></pre></td></tr></table></figure><p>pair还可以用来比较大小，前提是对pair里面的数据类型重载了比较运算符。注意：需要相同类型的pair才能够比较大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>,std::string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;HH&quot;</span>)</span></span>;<br><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>,std::string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;FF&quot;</span>)</span></span>;<br><span class="hljs-type">bool</span> result = p1&lt;p2;<span class="hljs-comment">//result 为true</span><br></code></pre></td></tr></table></figure><h2 id="tuple">tuple</h2><blockquote><p>tuple和pair类似,但其可以拥有若干个成员,可以在函数拥有多个返回值的时候使用</p></blockquote><p>tuple和python的tuple有些区别.python的tuple值无法更改,而c++的tuple是可以更改的.</p><p><strong>使用样例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建</span><br><span class="hljs-keyword">auto</span> i = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1.2</span>,<span class="hljs-string">&quot;tuple&quot;</span>,<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//使用tuple来对多变量进行方便赋值,我们有std::tie函数,返回左值引用的元组</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br><span class="hljs-type">bool</span> d;<br>std::<span class="hljs-built_in">tie</span>(a,b,c,d) = i;<span class="hljs-comment">//这四个变量的值都会相应地改变</span><br><br><span class="hljs-comment">// 获取单个数据,使用std::get函数</span><br><span class="hljs-comment">//get函数可以返回一个引用,对tuple数据进行更改</span><br><span class="hljs-type">int</span> f = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(i);<span class="hljs-comment">//f=1</span><br>std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(i) = <span class="hljs-number">2</span>;<span class="hljs-comment">//更改tuple中的值,注意下标在编译时要确定,即不能是变量,否则会报错</span><br><br><br></code></pre></td></tr></table></figure><h2 id="vector">vector</h2><blockquote><p>vector是一个非常基本的容器,类似于数组,但更加安全有效.</p></blockquote><p>vector可以像数组一样直接用下标访问,且速度较快.</p><p><strong>基本方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>temp.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回数组长度</span><br>temp.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清空</span><br><br><br><span class="hljs-comment">//修改操作</span><br>temp.<span class="hljs-built_in">pop_back</span>();<br>temp.<span class="hljs-built_in">push_back</span>(num);<span class="hljs-comment">//在末尾进行删增操作,高速</span><br><br>temp.<span class="hljs-built_in">insert</span>(x.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">5</span>);<br>temp.<span class="hljs-built_in">erase</span>(x.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">//使用迭代器来删改,低速</span><br><br><br></code></pre></td></tr></table></figure><h3 id="vector-iterator">vector iterator</h3><blockquote><p>vector iterator提供了一个访问vector数据的一个抽象统一接口,使用方法类似于指针,是一种数据类型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><span class="hljs-keyword">auto</span> i = temp.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//指向开头的迭代器</span><br><span class="hljs-keyword">auto</span> j = temp.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//指向末尾后一个的迭代器,即使用begin ,end要注意是左闭右开区间</span><br><br><span class="hljs-comment">//iterator重载了运算符,可以像数一样运算操作</span><br><span class="hljs-keyword">auto</span> iter = temp.<span class="hljs-built_in">begin</span>();<br>iter++;<br>iter +=<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//类似指针的使用</span><br>*iter = <span class="hljs-number">1</span>;<span class="hljs-comment">//返回左值引用</span><br></code></pre></td></tr></table></figure><h4 id="vector迭代器中需要注意的地方">vector迭代器中需要注意的地方</h4><p>迭代器有时候会<strong>失效</strong>,即不再指向原本应该指向的元素.</p><p>比如删除了一个元素后,原本指向该元素的迭代器就会指向后一个元素.</p><p>会导致迭代器失效的一些操作:</p><ul><li>删除,增加某个元素,在这个元素之后的迭代器都失效</li><li>增加vector的长度</li></ul><p>原因:当vector达到capacity后,会自动扩容,重新申请一片capacity*2的空间,并将数据转移到新的空间中.但是原来的迭代器仍然指向旧的空间,因此迭代器失效.</p><p>为了防止迭代器失效,可以查阅 iteratorvalidity,或者遵循绝对安全的准则:</p><blockquote><p>修改容器后,不要再使用原来的迭代器</p></blockquote><h2 id="list">list</h2><blockquote><p>list是使用双向链表实现的一个容器</p></blockquote><p>特点:</p><ul><li>不支持下标随机访问</li><li>支持在任意位置<strong>高速</strong>插入</li><li>主要依赖于迭代器来访问数据</li><li>进行操作和删改不会对除了被操作对象外的迭代器失效</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::list&lt;<span class="hljs-type">int</span>&gt; l;<br>l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//查询</span><br>std::list&lt;<span class="hljs-type">int</span>&gt;::iterator iter = l.<span class="hljs-built_in">find</span>(iterator begin,iterator end,value);<br>l.<span class="hljs-built_in">insert</span>(iter);<br><br><br></code></pre></td></tr></table></figure><h2 id="map">map</h2><blockquote><p>map是数据的映射。将一个数据项映射到另一个数据项中。map中每个元素类型是pair。</p></blockquote><p><strong>map的使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;std::string,<span class="hljs-type">int</span>&gt; m;<span class="hljs-comment">//将string映射到int中</span><br><br><span class="hljs-comment">//创建元素</span><br>m[<span class="hljs-string">&quot;闰年天数&quot;</span>] = <span class="hljs-number">366</span>; <span class="hljs-comment">//如果map中没有对应的key,则会自动生成一个新的pair,否则修改原key对应的value</span><br>m.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;平年天数&quot;</span>,<span class="hljs-number">365</span>));<span class="hljs-comment">//通过insert来创建</span><br><br><span class="hljs-comment">//使用元素</span><br>std::map&lt;std::string,<span class="hljs-type">int</span>&gt;::iterator iter = m.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;平年天数&quot;</span>);<span class="hljs-comment">//查询key,返回迭代器</span><br>m.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;key&quot;</span>);<span class="hljs-comment">//查询key出现的次数,只能是1或者0</span><br>m.<span class="hljs-built_in">erase</span>(iter);<span class="hljs-comment">//删除迭代器对应的元素</span><br><br><br></code></pre></td></tr></table></figure><h2 id="set">set</h2><blockquote><p>set就是一个集合,和数学上集合的性质一样,不能有重复的元素</p></blockquote><p>set是一个无序集合,内部的排序是按照元素的大小进行排序,而不是插入元素的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::set&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">insert</span>(value);<span class="hljs-comment">//如果value不存在,则创建对应的值;如果存在,那么操作无效果.</span><br><br>std::set&lt;<span class="hljs-type">int</span>&gt;::iterator iter = s.<span class="hljs-built_in">find</span>(value);<br>s.<span class="hljs-built_in">erase</span>(iter);<span class="hljs-comment">//寻找元素和删除元素的方法与map一致</span><br><br><br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>序列容器:vector,list</p><p>关联容器:map,set</p><p>序列容器可以按顺序访问, 元素有顺序</p><p>关联容器可以按数值大小访问,元素无顺序</p><p>每一个容器都有特定的优缺点,需要根据使用场景来恰当选择.</p>]]></content>
    
    
    <categories>
      
      <category>c++笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用python实现图书馆在线预约系统自动抢座</title>
    <link href="/2022/06/26/TECH-lib-reserve/"/>
    <url>/2022/06/26/TECH-lib-reserve/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>我平时都是在北馆自习，这边的座位比较充足。文图的环境虽好，但是座位几乎全天爆满，特别是在高峰时期，座无虚席。所以一直也没有动过去文图的念头，不跟人家争。但是架不住那里的座位实在是太舒服了...一人独占半张桌子，中间还有隔板，环境比北馆实在是要好太多，就开始想办法看看怎么样才能搞到座位。观察了一下发现，只有提前预约第二天早上八点中的座位才比较充足，其他时间段（上午下午）都是基本没有座位。但是一般来说，每隔一段时间就会有一个人离开图书馆，这个时候就会有一个座位空缺。如果手速足够快，就能在别人预约之前抢到这个座位，然后就可以享受在文图的快乐学习生活了。</p><p>刚好寒假的时候稍微学了一点点相关知识，就想着能不能运用一下那些知识去实现一下自动刷新和自动预约座位的功能。</p><h1 id="实现">实现</h1><h2 id="查看座位余量">查看座位余量</h2><h3 id="单层座位查询">单层座位查询</h3><p>先去实现查询座位余量。因为我只需要预约文图的座位，我就只针对文图进行分析，其他图书馆同理。</p><p>首先明确一下，我们目前需要的数据就是<strong>文图的每一层的座位余量，以及每一个区的座位余量</strong>，以方便我们后续的处理。</p><p>从主界面点开文科图书馆，发现里面有四个楼层。我们先点进其中一个楼层。观察一下，这个时候页面中已经显示了该层对应的每个区的座位余量了。</p><p><img src="/2022/06/26/TECH-lib-reserve/floors.png"> <img src="/2022/06/26/TECH-lib-reserve/floor_detail.png"></p><p>然后我们推测一下：这个页面应该是通过xhr数据传输来获取每一层楼的座位余量数据，而不是通过html文件静态传输。在源文件中简单搜索一下座位余量108，发现并没有搜索结果。而抓包之后可以看到，的确是通过xhr数据传输将图书馆座位各种信息传到本地中。</p><p><img src="/2022/06/26/TECH-lib-reserve/search.png"></p><p>这是抓包发现的接口。也就是说，座位量等各种信息就是通过请求这个接口来获取的。</p><p><img src="/2022/06/26/TECH-lib-reserve/package.png"></p><p>我们模拟抓包一下，保存下来传输的json数据，打开可以发现它是这样的一个数据结构：</p><p><img src="/2022/06/26/TECH-lib-reserve/data_structure.png"></p><p>我们慢慢分析一下，找到我们需要的目标数据。</p><p>我们发现，在childarea这个字段里面有我们需要的数据。</p><p><img src="/2022/06/26/TECH-lib-reserve/child_area.png"></p><p>我们看到了“c区”的字样，然后还找到了“TotalCount”“UnavailableSpace”字段，也许座位存量的数据就是这几个关键信息。然后我们简单验证一下。通过网页中显示的座位剩余数据，和我们自己抓包得到的totalcout减去unavailablespace的结果比对，发现这两个数据刚好吻合。由此证明我们的猜想是正确的。然后在childarea字段里面，还有很多其他区的信息，如法炮制即可。</p><p><img src="/2022/06/26/TECH-lib-reserve/area_A.png"></p><p>经过上面的分析，我们已经可以得到图书馆一层楼中的每个区域的座位量了。简单总结一下就是，我们通过抓包到的接口获取一个json数据，然后找到childarea字段，分别读取每个区域的totalcount，unavailablespace的数据，然后相减，即可得出每个区域的座位剩余量。</p><h3 id="多层查询">多层查询</h3><p>只有一层的数据显然是不完全的。我们还需要获取其他层的数据。</p><p>观察一下我们刚才获取数据的url：https://seat.lib.tsinghua.edu.cn/api.php/v3areas/91然后我们按照刚才的步骤，再去手动获取一下其他楼层的数据，发现其他楼层的url都是呈现这样的一个结构：https://seat.lib.tsinghua.edu.cn/api.php/v3areas/ +一个数字</p><p>看来这个数字就是控制获取不同楼层的数据的一个关键字段。这个数字是什么意思?</p><p>我们回到主页，然后发现每点进一个不同的图书馆区查看座位量的时候，url是发生变化的。也就是说，url决定着你查询的图书馆种类，甚至是楼层。</p><p>然后点入每一个图书馆都看了一遍，关注一下url的变化。</p><p>发现不管是什么图书馆，什么楼层，url都是这样的格式：http://seat.lib.tsinghua.edu.cn/web/seat/area/ + 一个数字</p><p>我们可以猜测：每一个数字其实就代表着某个图书馆的某个楼层。经过简单推理验证就可以知道这个猜想是正确的。然后再实测一下，我们发现：对于文科图书馆，1-4楼对应的数字就是90-93。那就非常好办了。我们只需要分别将90~93拼在上面的url上，比如https://seat.lib.tsinghua.edu.cn/api.php/v3areas/93，通过这个url就可以获取文图第四层的座位信息，然后按照上面的方法就能够读取每个区域的座位余量了。</p><h2 id="实现自动抢座">实现自动抢座</h2><p>我们直接通过一次实际的座位预约操作，然后抓包分析来看看如何进行。因为我现在不在图书馆，如果实操演示的话我可能会不小心预约成功，就得赶过去刷卡签到，不然记一次违约。。。所以现在没有办法实地演示一遍，只能讲个大概。</p><p>先看看图书馆最终预约的界面</p><p><img src="/2022/06/26/TECH-lib-reserve/reserve.png"></p><p><img src="/2022/06/26/TECH-lib-reserve/confirm.png"></p><p>我们通过点击绿色的座位，然后点击确定，即可预约成功。我们分析一下完成这一步需要走的流程：首先通过统一账号认证系统登录，然后点进对应的图书馆，点进对应的楼层和区域，进到上述界面。然后点击预约。这个过程涉及的步骤比较多，我们用分析法来慢慢寻找线索。</p><p>关键的一步就是点击预约然后确定。依旧是抓包大法。我们发现了一个关键接口：http://seat.lib.tsinghua.edu.cn/api.php/spaces/' seat_num'/book?access_token=' token '&amp;userid=' student_id '&amp;segment='segment '&amp;type=1&amp;operateChannel=2</p><p>也就是说，最终的预约请求是通过post方法，通过这个url来上传到服务器的。这个url是我已经分析修改过的版本。分析得出，我们需要以下几个参数就可以实现座位预约：</p><ul><li>座位序号</li><li>token</li><li>userid</li><li>segment</li></ul><p>当我们拿到上述四个正确的参数之后，我们就可以通过post方法实现座位预约了。</p><p>补充：这个系统并不需要cookie验证</p><p><strong>座位序号</strong>这个序号获取的方法和座位余量的获取十分类似。我们同样点开具体某个楼层的页面，然后抓包，就可以找到包含每个座位信息的一个json数据。这个json数据包括：每个座位的座位编号，每个座位的状态信息，包括是否能够预约等等。</p><p><strong>token</strong>这个token的获取想必就是通过统一账号认证获取的了。涉及到token的获取有点点麻烦，我直接贴代码在下面了。其实也是就模拟一遍账号认证的登录，通过学生账号密码获取临时token的一个操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#if login sucessfully,then return the token , otherwise return -1.</span><br>      data = &#123;<br>         <span class="hljs-string">&quot;i_user&quot;</span>: self.student_id,<br>         <span class="hljs-string">&quot;i_pass&quot;</span>: self.student_paw,<br>        <span class="hljs-comment">#  &quot;i_captcha&quot;:&quot;&quot;</span><br>     &#125;<br>      init_url = <span class="hljs-string">&quot;https://id.tsinghua.edu.cn/do/off/ui/auth/login/form/ef84f6d6784f6b834e5214f432d6173f/0?/api/id_tsinghua_callback&quot;</span><br><br>      login_url = <span class="hljs-string">&quot;https://id.tsinghua.edu.cn/do/off/ui/auth/login/check&quot;</span><br>      session = requests.session()<br>      session.headers.update(self.myheader)<br><br>      res1 = session.get(init_url, headers=self.myheader)  <br>      res2 = session.post(login_url, data=data, headers=self.myheader)<br>      <span class="hljs-comment"># print(res2.text)</span><br>      reg_obj = re.search(<span class="hljs-string">r&#x27;ticket=(.+)&quot;&#x27;</span>,res2.text)<br>      <span class="hljs-keyword">if</span>(reg_obj==<span class="hljs-literal">None</span>):<br>         <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>userid</strong> 其实就是学生的学号</p><p><strong>segment</strong>这个大概是和时间有关的一个参数，可以参考网页源码去生成，或者是自己观察规律蛮力生成（我选择了大力出奇迹</p><p>好，那么现在工作已经差不多完成了。我们只需要将刚才获取的四个数据通过post传送到对应的url中，然后对传回来的提示数据进行一些处理即可。如果预约成功，返回的数据会有“预约成功”字样，直接通过正则表达式提取即可。</p><p>接下来就是对整个程序进行一个小小的封装，也就基本完成了。具体就是在脚本打开的时候先模拟登录获取token，然后设定一个频率，比如五秒钟，自动查询一次座位剩余量，如果没有剩余，则继续查询；如果有座位剩余，直接获取该空余座位的座位信息，然后将上述提到的四个数据合成一个url，通过post发送到服务器。最后对服务器的结果进行反馈处理。</p><h1 id="总结">总结</h1><p>整个自动预约系统分为两个部分：座位余量查询和自动预约座位。先通过一定的频率自动查询座位剩余量，一旦发现有剩余量，就查询到空余的座位信息，然后自动预约该座位，完成。</p><p>本脚本中有几个比较关键的点：</p><ul><li>弄清楚图书馆url的规律，每个楼层对应的数字，以及一些其他参数的意义和生成<ul><li>根据url规律，抓包获取对应数据</li><li>随后根据得到的数据正确提取座位信息</li></ul></li><li>模拟统一账号认证登录的过程，获取token</li><li>通过抓包分析出预约系统的操作过程，然后分析需要的各种参数，分别找到各参数的获取方法，最后拼接在一起上传，对返回结果进行处理。</li></ul><p>最后，本文需要一定的基础知识，包括但不限于：</p><ul><li>网页的基本组成</li><li>浏览器和服务器的基本交互过程</li><li>http的简单知识</li></ul><p>以上这些知识在本文中涉及到的部分其实都非常地简单，不会有非常深入的知识。如果想尝试一下的话，可以通过python的爬虫教程来慢慢入门，learnbydoing。通过对爬虫的简单学习，了解浏览器的一些工作流程，和如何模拟浏览器进行操作。该自动预约座位脚本本质上其实就是模拟浏览器进行操作的这么一个过程。</p><p>END</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建历程</title>
    <link href="/2022/06/25/TECH-blog-create/"/>
    <url>/2022/06/25/TECH-blog-create/</url>
    
    <content type="html"><![CDATA[<p><strong>折腾 折腾 还是折腾</strong></p><p>从开始学习搭建博客，到现在基本能够投入使用，中间还是经历了不少的曲折的道路，投入了相当的精力。简单回忆一下，我的博客搭建之路为：</p><ol type="1"><li>使用hexo + GitHub pages 搭建</li><li>使用自己的云服务器+nginx+hexo搭建</li><li>使用hexo + GitHub pages + netlify （目前使用）</li></ol><h1 id="尝试过程">尝试过程</h1><h2 id="hexo-github-pages">hexo + github pages</h2><p>hexo的使用十分简单，对于博客新手来说十分友好，我就选择了hexo来进行上手了。hexo的原理就是在本地配置好相应的环境，然后在本地直接生成渲染对应的网站文件。然后需要借助GitHubpages来部署生成的网站文件，让其他人能够在互联网上访问到你的博客。</p><p>按照教程一步步来，搭建hexo环境就已经完成了一半了。然后剩下的就是和GitHubpages的联动。首先还是需要建立对应的GitHub仓库，然后建立本地计算机和GitHub仓库的ssh，配置好后以后就可以在本地写好网站，然后直接更新GitHub仓库内容，自动部署。再然后就是继续配置一些GitHubpages上的小细节，基本就完成了。严格按照教程来走一趟，不出啥意外的话一个小时就能够配好了。</p><p>的确一开始也很顺利，在本地试运行了之后，然后成功通过GitHubpages给的url去访问了！</p><h3 id="问题出在哪">问题出在哪？</h3><p>有两座大山摆在面前。一个是域名问题，一个是GitHub的某些众所周知的速度慢的问题。</p><h3 id="速度慢">速度慢</h3><p>这是后来折腾来折腾去的一大问题。GitHub因为国内某些原因，时不时会抽风，根本无法正常访问。即使能够访问，速度也非常不稳定，最慢的时候加载一张图片超过了一分钟！显然一个正经的博客不能容忍这样的问题出现。</p><h3 id="域名">域名</h3><p>其实如果没有第一个问题，域名也不算是什么问题。觉得GitHub给的自带的域名太长了不好记，于是自己买了一个域名，方便访问。如果没有第一个问题，只需要简单地将买来的域名指向GitHub给的链接就可以很顺利地完成域名解析的任务，就可以通过自定的域名来访问。</p><p>但是加载速度慢啊。</p><p>那怎么办？不能每次进来都等个几分钟，然后就为了看那几张图片吧？</p><h2 id="hexo-nginx">hexo + nginx</h2><p>(补充更新：还折腾了一下cdn（content delivery network)，尝试为GitHubpages加速，后来因为问题越来越多不得不暂时放弃了。)</p><p>既然GitHubpages提供的服务比较慢，那我就不用它了吧。我用自己的服务器。有服务器还愁没法搭建网站？</p><p>还真是愁。</p><p>又是一番找教程自学摸索，折腾了老半天，终于在linux服务器上搭建了nginx，然后再配置好hexo环境。</p><p>在本地写好，push到服务器，启动服务。紧张兮兮地先打开公网ip试试，成了！能进去了！而且访问速度比pages快了不知多少倍。</p><p>半天过去，以为终于差不多能够结束了，就差将自己的域名指向服务器IP了。我兴冲冲地点开域名管理，修改指向，然后静静地等待生效。</p><p>等了半小时，刷新网站，发现有变化了！</p><p>但是这变化不太妙。</p><p>乐，在国内服务器搭建的网站都需要备案。你用IP可以访问，但是一旦绑定了域名，就必须要在公安系统备案才能够运行。</p><p>谁会用IP去访问一个网站啊...</p><p>行，那我去备案。</p><h3 id="备案">备案</h3><p>去到腾讯云的备案接口，稍微看了一眼要求，就看到以下这么一点： &gt;备案的域名必须是在国内注册的。</p><p>然而我的域名是在namesilo里面购买的，属于国外注册，无法使用这个域名来进行备案，除非将它转到国内。</p><p>一想到要将域名转到国内已经头大了。。。然后还是硬着头皮去摸索怎么转到国内。</p><p>就在这时，我突然看到，<strong>新注册的域名必须经过60天后才能转到国内</strong>。好了，这下省下来这些功夫了，根本转不回来。</p><p>域名备案宣告破产。</p><p>使用国内服务器搭建宣告破产。</p><h2 id="hexo-netflix-github-pages">hexo + Netflix + GitHub pages</h2><p>既然无法使用国内的服务器搭建，但是我又舍不得放弃我的域名，那就看看能不能找到其他的地方去部署网站吧。gitee似乎是一个比较不错的选择，同样有pages功能，跟GitHub长得也比较类似。那就试试gitee吧。</p><p>然后发现gitee要实名验证。实名验证不只是输入身份证号码，还需要上传身份证正反面证件，上传手持身份证照片...心理膈应，直接放弃gitee了。btw，gitee的public仓库还要审核...</p><p>兜兜转转回到GitHub。就在我觉得山穷水尽的时候，忽然发现了netflix。</p><blockquote><p>什么是Netlify？ Netlify是部署Githubpages站点的绝佳选择。Netlify是一个统一平台，可自动执行代码，以创建高性能，易于维护的站点和Web应用程序。它们提供持续部署，智能的全局CDN，完整的DNS（包括自定义域），自动HTTPS，资产加速等等。</p></blockquote><p>而且netlify<strong>没有被墙，没有被墙，没有被墙。</strong>在国内可以以正常的速度访问！！</p><p>迅速注册netlify，然后关联GitHub，将原GitHubpages文件部署到netlify上。然后netlify就会给出一个特定的url，通过这个url就可以访问netlify上你的GitHub项目部署的网站了。同时，你在GitHub仓库上的commit会实时更新到netlify上，然后自动部署，非常地省心。</p><p>最后，只需要在我的域名管理器上修改dns服务器，改为netlify提供的四个地址，然后将cname指向netlify给出的url，保存，等待生效，完成！</p><p>最终效果=GitHub pages效果。</p><p>一个完整的发布流程和GitHubpages一样，本地生成，push到GitHub，然后稍等片刻，就可以看到修改后的版本。可以直接通过自定义的url进行访问网站，并且速度有了质的提升。至此，博客搭建折腾之路基本结束，差不多可以专心去写内容了。</p><h2 id="总结">总结</h2><p>使用hexo搭建博客非常地方便，重点是在于将其正确地部署，并让其他人能够方便地访问你的博客。踩坑总结：</p><ul><li>使用GitHub pages部署很方便，但是速度不稳定，容易崩。</li><li>国内服务器搭建的网站如果想使用自定义域名而不是公网IP访问，就必须要备案。<ul><li>备案要求你的域名是国内注册商。</li><li>新域名必须过60天后才能转回国内。</li></ul></li><li>gitee需要比较严格的实名验证，不太让人放心。</li></ul><p>搭建流程总结：</p><ul><li>使用hexo配置好环境</li><li>创建好GitHub项目，并正确配置好pages setting</li><li>使用netlify关联GitHub repository</li><li>将自己的域名解析到netlify上</li></ul><h1 id="后记">后记</h1><p>嗯...折腾确实是非常耗费时间，但是也在这个过程中学会了很多相关的知识点，也算是比较有收获。这篇博客算是对自己建站之路的大致总结，并不是新手友好向（但是可以踩雷参考）。实际的搭建过程中会有非常多的细节需要注意。更详细的搭建教程我会贴在下面，想尝试的可以参考参考。只有亲自去实践才会知道问题是会层出不穷的。在不断折腾的过程中，也能学会很多知识，掌握遇到问题解决问题的能力。</p><p>因为最近实在太热，不想出门，躲宿舍吹空调很快乐，所以植物的先鸽了（</p><p>会继续更新一些技术学习笔记，或者是某些读书笔记等。权当写个乐呵。</p><p><strong>搭建博客教程（新手向）</strong></p><p><a href="https://zhuanlan.zhihu.com/p/60578464">使用hexo+GitHubpages免费搭建个人博客</a></p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!!!</title>
    <link href="/2022/06/01/Hello-World/"/>
    <url>/2022/06/01/Hello-World/</url>
    
    <content type="html"><![CDATA[<!-- ![](Hello-World/index.jpg) --><p>国际惯例： <strong>Hello World!!!</strong> <span id="more"></span></p><p><strong>猫猫镇楼</strong></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/1.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/5.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/6.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/2.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/3.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/4.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/7.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/8.jpg"></div><div class="group-image-wrap"><img src="/2022/06/01/Hello-World/9.jpg"></div></div></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
